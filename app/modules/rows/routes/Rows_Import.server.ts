import { LoaderFunctionArgs, redirect, ActionFunction, json } from "@remix-run/node";
import { MetaTagsDto } from "~/application/dtos/seo/MetaTagsDto";
import { Colors } from "~/application/enums/shared/Colors";
import { RowsApi } from "~/utils/api/.server/RowsApi";
import UrlUtils from "~/utils/app/UrlUtils";
import { EntityWithDetails } from "~/utils/db/entities/entities.db.server";
import { getMaxRowFolio, getRowById, RowWithDetails } from "~/utils/db/entities/rows.db.server";
import RowHelper from "~/utils/helpers/RowHelper";
import RowsRequestUtils from "../utils/RowsRequestUtils";
import { adminGetAllTenantsIdsAndNames, getTenant } from "~/utils/db/tenants.db.server";

export namespace Rows_Import {
  export type LoaderData = {
    meta: MetaTagsDto;
    entity: EntityWithDetails;
    allTenants: { id: string; name: string; slug: string }[];
  };
  export const loader = async ({ request, params }: LoaderFunctionArgs) => {
    const { t, tenantId, entity } = await RowsRequestUtils.getLoader({ request, params });
    if (!entity.isAutogenerated || entity.type === "system") {
      throw redirect(tenantId ? UrlUtils.currentTenantUrl(params, "404") : "/404");
    }
    const data: LoaderData = {
      meta: [{ title: `${t("shared.import")} ${t(entity.titlePlural)} | ${process.env.APP_NAME}` }],
      entity,
      allTenants: !tenantId ? await adminGetAllTenantsIdsAndNames() : [],
    };
    return json(data);
  };

  export interface ImportRow {
    properties: { name: string; value: string }[];
    row?: RowWithDetails | null;
    error?: string;
  }
  export type ActionData = {
    rows?: ImportRow[];
    error?: string;
  };
  export const action: ActionFunction = async ({ request, params }) => {
    const { t, userId, tenantId, entity, form } = await RowsRequestUtils.getAction({ request, params });
    const action = form.get("action");
    if (action === "import") {
      const tag = form.get("tag")?.toString() ?? "import";
      const rawRows: ImportRow[] = form.getAll("rows[]").map((f: FormDataEntryValue) => {
        return JSON.parse(f.toString());
      });
      let tenantToImport = tenantId;
      if (tenantId === null) {
        const selectedTenantId = form.get("selectedTenantId")?.toString() || "{null}";
        if (selectedTenantId === "{null}") {
          tenantToImport = null;
        } else {
          const existingTenant = await getTenant(selectedTenantId);
          if (!existingTenant) {
            return json({ error: "Invalid tenant with ID: " + selectedTenantId }, { status: 400 });
          }
          tenantToImport = selectedTenantId;
        }
      }

      if (rawRows.length === 0) {
        return json({ error: "No rows to import" }, { status: 400 });
      }
      const rows: ImportRow[] = [];
      let folio = 1;
      const maxFolio = await getMaxRowFolio({ tenantId: tenantToImport, entityId: entity.id });
      if (maxFolio && maxFolio._max.folio !== null) {
        folio = maxFolio._max.folio + 1;
      }
      await Promise.all(
        rawRows.map(async (importRow: ImportRow, idx) => {
          try {
            // Wait for keeping folios unique, I can't think of another way to do this
            await new Promise((r) => setTimeout(r, 1500));
            const rowValues = RowHelper.getRowPropertiesFromForm({ t, entity, values: importRow.properties });
            const newRow = await RowsApi.create({
              entity,
              tenantId: tenantToImport,
              userId,
              rowValues,
              nextFolio: folio + idx,
              request,
            });
            if (tag) {
              await RowsApi.addTag({ row: newRow, tag: { value: tag, color: Colors.INDIGO } });
            }
            importRow.row = await getRowById(newRow.id);
          } catch (e: any) {
            importRow.error = e.message?.toString();
          }
          rows.push(importRow);
        })
      );
      const data: ActionData = {
        rows,
      };
      return json(data);
    } else {
      return json({ error: "Invalid form" }, { status: 400 });
    }
  };
}
